## Паттерны проектирования 

Паттерны проектирования (шаблоны проектирования) - это готовые к использованию решения часто возникающих в программировании задач. Паттерны проектирования, подходящий под задачу, реализуется в каждом конкретном случае. Следует, помнить, что такой паттерн, будучи примененным неправильно или к неподходящей задаче, может принести немало проблем. Тем не менее, правильно примененный паттерн поможет решить задачу легко и просто.

Типы паттернов:
* порождающие
* структурные
* поведенческие
Порождающие паттерны предоставляют механизмы инициализации, позволяя создавать объекты удобным способом.

Структурные паттерны определяют отношения между классами и объектами, позволяя им работать совместно.

Поведенческие паттерны используются для того, чтобы упростить взаимодействие между сущностями.

Порождающие:
* Singleton (Одиночка) - ограничивает создание одного экземпляра класса, обеспечивает доступ к его единственному объекту.
* Factory (Фабрика) - используется, когда у нас есть суперкласс с несколькими подклассами и на основе ввода, нам нужно вернуть один из подкласса.
* Abstract Factory (Абстрактная фабрика) - используем супер фабрику для создания фабрики, затем используем созданную фабрику для создания объектов.
* Builder (Строитель) - используется для создания сложного объекта с использованием простых объектов. Постепенно он создает больший объект от малого и простого объекта.
* Prototype (Прототип) - помогает создать дублированный объект с лучшей производительностью, вместо нового создается возвращаемый клон существующего объекта.
Структурные:
* Adapter (Адаптер) - это конвертер между двумя несовместимыми объектами. Используя паттерн адаптера, мы можем объединить два несовместимых интерфейса.
* Composite (Компоновщик) - использует один класс для представления древовидной структуры.
* Proxy (Заместитель) - представляет функциональность другого класса.
* Flyweight (Легковес) - вместо создания большого количества похожих объектов, объекты используются повторно.
* Facade (Фасад) - беспечивает простой интерфейс для клиента, и клиент использует интерфейс для взаимодействия с системой.
* Bridge (Мост) - делает конкретные классы независимыми от классов реализации интерфейса.
* Decorator (Декоратор) - добавляет новые функциональные возможности существующего объекта без привязки его структуры.
Поведенческие:
* Template Method (Шаблонный метод) - определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
* Mediator (Посредник) - предоставляет класс посредника, который обрабатывает все коммуникации между различными классами.
* Chain of Responsibility (Цепочка обязанностей) - позволяет избежать жесткой зависимости отправителя запроса от его получателя, при этом запрос может быть обработан несколькими объектами.
* Observer (Наблюдатель) - позволяет одним обьектам следить и реагировать на события, происходящие в других объектах.
* Strategy (Стратегия) - алгоритм стратегии может быть изменен во время выполнения программы.
* Command (Команда) - интерфейс команды объявляет метод для выполнения определенного действия.
* State (Состояние) - объект может изменять свое поведение в зависимости от его состояния.
* Visitor (Посетитель) - используется для упрощения операций над группировками связанных объектов.
* Interpreter (Интерпретатор) - определяет грамматику простого языка для проблемной области.
* Iterator (Итератор) - последовательно осуществляет доступ к элементам объекта коллекции, не зная его основного представления.
* Memento (Хранитель) - используется для хранения состояния объекта, позже это состояние можно восстановить.

## SOLID

S – Single Responsibility (Принцип единственной ответственности)

Каждый класс должен отвечать только за одну операцию.

Hазначение

Принцип служит для разделения типов поведения, благодаря которому ошибки, вызванные модификациями в одном поведении, не распространялись на прочие, не связанные с ним типы.

O — Open-Closed (Принцип открытости-закрытости)

Классы должны  быть  открыты для расширения, но закрыты для модификации.

Назначение

Принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс.

L — Liskov Substitution (Принцип подстановки Барбары Лисков)

Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы.

Назначение

Принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться одинаковым образом без нарушения работы программы.

I — Interface Segregation (Принцип разделения интерфейсов)

Не следует ставить клиент в зависимость от методов, которые он не использует.
Назначение

Принцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше – таким образом, каждый класс делает то, что от него действительно требуется, и ничего больше.

D — Dependency Inversion (Принцип инверсии зависимостей)

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
Назначение

Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов.

## MAVEN
 Инструмент для управления и сборки проектов

pom.xml - главный файл для управления Мавеном. Все описание проекта содержится здесь.

Благодаря Мавену не нужно тратить время на поиски нужной библиотеки в интернете, качать ее, а потом подключать к проекту: достаточно добавить необходимую в список зависимостей Мавена.

Сборка с помощью maven 
Существует 9 фаз:
1. clean — удаляются все скомпилированные файлы из каталога target (место, в котором сохраняются готовые артефакты);
2. validate — идет проверка, вся ли информация доступна для сборки проекта;
3. compile — компилируются файлы с исходным кодом;
4. test — запускаются тесты;
5. package — упаковываются скомпилированные файлы (в jar, war и т.д. архив);
6. verify — выполняются проверки для подтверждения готовности упакованного файла;
7. install — пакет помещается в локальный репозиторий. Теперь он может использоваться другими проектами как внешняя библиотека;
8. site — создается документация проекта;
9. deploy — собранный архив копируется в удаленный репозиторий.
Все фазы выполняются последовательно: нельзя запустить, скажем, четвертую фазы, пока не завершены фазы 1-3. 

