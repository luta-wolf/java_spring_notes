##  Что такое daemon тред?
Daemon thread (далее — демон-тред) — это тред, который выполняет задачи в фоне по отношению к другому потоку. То есть, его работа заключается в том, чтоб выполнять задачи вспомогательные, которые нужно делать только в привязке другому (основному) потоку. 

Есть много потоков демонов, работающих автоматически, например Garbage Collector, finalizer и т. д.
Почему Java закрывает демон-поток?
Единственная цель потока демона состоит в том, что он предоставляет сервисы потоку пользователя для фоновой задачи поддержки. Поэтому если основной поток завершился, то runtime закрывает автоматически и все его демон-потоки.

Мы можем создать поток демона только до его запуска.

## Что такое volatile переменная?
Ключевое слово volatile используется в многопоточном программировании для обеспечения безопасности потока, поскольку модификация одной изменяемой переменной видна всем другим потокам, поэтому одна переменная может использоваться одним потоком за раз.

При помощи ключевого слова volatile можно гарантировать, что переменная будет потокобезопасна и будет храниться в общей памяти, и потоки не будут ее брать себе в свой кеш.

## Что такое синхронизация (synchronization)?
Синхронизация (Synchronization) в Java — это возможность контролировать доступ нескольких потоков к любому общему ресурсу.

Когда несколько потоков пытаются выполнить одну и ту же задачу, существует вероятность ошибочного результата, поэтому для устранения этой проблемы Java использует синхронизацию, благодаря которой будет только один тред сможет работать в один момент.

Синхронизация может быть достигнута тремя способами:
* Синхронизируя метод
* Синхронизируя определенный блок
* Статической синхронизацией
Синхронизация метода
Синхронизированный метод используется для блокировки объекта для любого общего ресурса. Когда поток вызывает синхронизированный метод, он автоматически получает блокировку для этого объекта и снимает ее, когда поток завершает свою задачу.

Чтоб заработало, нужно добавить ключевое слово synchronized. 
Блок синхронизации
Синхронизированный блок может быть использован для выполнения синхронизации на любом конкретном ресурсе метода. 

Допустим, что в большом методе(да да, такие писать нельзя, но иногда бывает) нужно синхронизировать только небольшую часть, по каким-то причинам.

Если вы поместите все коды метода в синхронизированный блок, он будет работать так же, как синхронизированный метод.

Статическая синхронизация
Если сделать статический метод синхронизированным, то блокировка будет на классе, а не на объекте.

## Что такое shutdownhook?
Shutdownhook — это поток, который неявно вызывается до завершения работы JVM(виртуальная машина Java). Таким образом, мы можем использовать его для очистки ресурса или сохранения состояния, когда виртуальная машина Java выключается нормально или внезапно. 

##  Каковы состояния в жизненном цикле потока
1. New: В этом состоянии объект класса Thread создается с использованием оператора new, но поток не существует. Поток не запускается, пока мы не вызовем метод start().
2. Runnable: В этом состоянии поток готов к запуску после вызова метода start(). Однако он еще не выбран планировщиком потока.
3. Running: В этом состоянии планировщик потока выбирает поток из состояния готовности, и тот работает.
4. Waiting/Blocked: в этом состоянии поток не работает, но все еще жив или ожидает завершения другого потока.
5. Dead/Terminated: при выходе из метода run() поток находится в завершенном или мертвом состоянии.

## Concurrency

это библиотека классов в Java, в которой собрали специальные классы, оптимизированные для работы из нескольких нитей. Эти классы собраны в пакете java.util.concurrent.
Concurrent Collections — набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета. Вместо базового враппера Collections.synchronizedList с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа для параллельного чтения данных по wait-free алгоритмам.

Queues — неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков. Блокирующие очереди используются, когда нужно «притормозить» потоки «Producer» или «Consumer», если не выполнены какие-либо условия, например, очередь пуста или перепонена, или же нет свободного «Consumer»'a.

Synchronizers — вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.

Executors — содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов. 

Locks — представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.

Atomics — классы с поддержкой атомарных операций над примитивами и ссылками.