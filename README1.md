# All on My Mac

## Beans


Бинами принято называть те объекты, которые управляются Spring-ом и живут внутри его DI-контейнера. Бином является почти все в Spring — сервисы, контроллеры, репозитории, по сути все приложение состоит из набора бинов. Их можно регистрировать, получать в качестве зависимостей, проксировать, мокать и т.п.

Область видимости (scope) то как создается бин 
* singleton - По умолчанию. Spring IoC контейнер создает единственный экземпляр бина. Как правило, используется для бинов без сохранения состояния(stateless)
* prototype - Spring IoC контейнер создает любое количество экземпляров бина. Новый экземпляр бина создается каждый раз, когда бин необходим в качестве зависимости, либо через вызов getBean(). Как правило, используется для бинов с сохранением состояния(stateful)
* request - Жизненный цикл экземпляра ограничен единственным HTTP запросом; для каждого нового HTTP запроса создается новый экземпляр бина. Действует, только если вы используете web-aware ApplicationContext
* session - Жизненный цикл экземпляра ограничен в пределах одной и той же HTTP Session. Действует, только если вы используете web-aware ApplicationContext
* global session - Жизненный цикл экземпляра ограничен в пределах глобальной HTTP Session( Действует, только если вы используете web-aware ApplicationContext
* application - Жизненный цикл экземпляра ограничен в пределах ServletContext. Действует, только если вы используете web-aware ApplicationContext
* 
Жизненный цикл Бина

1. Запуск Спринг-приложения  -> запуск Спринг-контейнера -> создается объект бина -> Внедряются зависимости(DI) -> вызывается синит метод -> Бин готов
2. Вызывается дестрой метод -> остановка приложения.


@Component - аннотация которой ставим над классом бин которого хотим создать

@Autowired   - аннотация(обычно над конструктором( полях, сеттерах), класса или интерфейса) для внедрения зависимостей, Спринг сканирует классы если находится подходящий бин - он внедряется в качестве зависимости 

## База про ооп

- [ ] База про ооп
- [ ] Стримы
- [ ] Параллел стрим
- [ ] ENUM
- [ ] Статик и всё про него
- [ ] Функциональные интерфейсы 
- [ ] интерграционные тесты

- [x] Synchronized( запись в многопоточке в переменную)
- [ ] Многопоточка( callable future executor service мониторы, классы, https://javarush.ru/groups/posts/2047-threadom-java-ne-isportishjh--chastjh-i---potoki)
- [ ] Concurrent
- [ ] паттерны программирования
- [x] Волатайл(когерентность кэшей, переменная не кешируется, считывание)
- [x] Сериализация
- [ ] Атомарные типы(Механизм CAS)
- [ ] Servlet
- [ ] Forkjoinpool
- [ ] Executor service

- [ ] Jdbc native запросы, criteria api
- [ ] БД(Индекс,Джоины, DCL и тд, нормальные формы, Group by)
- [ ] Sql группы команд( DDL(сreate table), DML(insert), DCL(grant access)
- [x] Транзакции уровни изоляции транзакций
- [x] ACID
- [ ] Native

- [ ] N+1 problem
- [ ] Propagation level spring data
- [ ] Spring ( видео алишев)
- [x] Bean( как создать, как получить, видео алишев)
- [ ] Spring boot
- [ ] Hibernate & JPA состояние объектов 
- [ ] Hibernate (как работает прям с нуля как в коде получается, запросы в хибернейт, hql уровни кеширования)
- [ ] Виды контекстов
- [ ] REST архитектура
- [x] Скоупы бинов(для чего нужны) 
- [x] Что  делает Maven

- [x] SOLID
- [ ] Socket

- [ ] НTTP

## Leetcode

linked lists:
- [ ]     https://leetcode.com/problems/merge-k-sorted-lists/
- [x]     https://leetcode.com/problems/linked-list-cycle/
- [x]     https://leetcode.com/problems/add-two-numbers/
- [x]     https://leetcode.com/problems/reverse-linked-list/
 
binary search:
- [x]     https://leetcode.com/problems/binary-search/
- [x]     https://leetcode.com/problems/guess-number-higher-or-lower/
- [ ]     https://leetcode.com/problems/search-a-2d-matrix/
- [ ]     https://leetcode.com/problems/search-in-rotated-sorted-array/
- [x]     https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
- [ ]     https://leetcode.com/problems/search-in-rotated-sorted-array-ii/
 
hash table:
- [x]     https://leetcode.com/problems/single-number/ - решить за O(1) по памяти
- [x]     https://leetcode.com/problems/two-sum/
- [ ]     https://leetcode.com/problems/4sum/
- [ ]     https://leetcode.com/problems/group-anagrams/
- [x]     https://leetcode.com/problems/valid-anagram/
- [ ]     https://leetcode.com/problems/find-all-anagrams-in-a-string/

queue/stack:
- [x]     https://leetcode.com/problems/valid-parentheses/

dfs/bfs:
- [ ]     https://leetcode.com/problems/number-of-islands/
- [ ]     https://leetcode.com/problems/remove-invalid-parentheses/
 
sort:
- [x]     https://leetcode.com/problems/merge-intervals/
 
heap/hash:
- [ ]     https://leetcode.com/problems/top-k-frequent-words/
- [ ]     https://leetcode.com/problems/top-k-frequent-elements/
 
two pointers:
- [ ]     https://leetcode.com/problems/container-with-most-water/
- [ ]     https://leetcode.com/problems/partition-labels/
 
sliding window:
- [ ]     https://leetcode.com/problems/sliding-window-median/
- [ ]     https://leetcode.com/problems/sliding-window-maximum/
- [ ]     https://leetcode.com/problems/longest-repeating-character-replacement/
 
tree:
- [x]     https://leetcode.com/problems/same-tree/
- [x]     https://leetcode.com/problems/symmetric-tree/
- [x]     https://leetcode.com/problems/balanced-binary-tree/
- [ ]     https://leetcode.com/problems/path-sum-ii/
 
greedy problems:
- [ ]     https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
- [ ]     https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/
- [ ]     https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/
- [ ]     https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/

## Паттерны проектирования 

Паттерны проектирования (шаблоны проектирования) - это готовые к использованию решения часто возникающих в программировании задач. Паттерны проектирования, подходящий под задачу, реализуется в каждом конкретном случае. Следует, помнить, что такой паттерн, будучи примененным неправильно или к неподходящей задаче, может принести немало проблем. Тем не менее, правильно примененный паттерн поможет решить задачу легко и просто.

Типы паттернов:
* порождающие
* структурные
* поведенческие
Порождающие паттерны предоставляют механизмы инициализации, позволяя создавать объекты удобным способом.

Структурные паттерны определяют отношения между классами и объектами, позволяя им работать совместно.

Поведенческие паттерны используются для того, чтобы упростить взаимодействие между сущностями.

Порождающие:
* Singleton (Одиночка) - ограничивает создание одного экземпляра класса, обеспечивает доступ к его единственному объекту.
* Factory (Фабрика) - используется, когда у нас есть суперкласс с несколькими подклассами и на основе ввода, нам нужно вернуть один из подкласса.
* Abstract Factory (Абстрактная фабрика) - используем супер фабрику для создания фабрики, затем используем созданную фабрику для создания объектов.
* Builder (Строитель) - используется для создания сложного объекта с использованием простых объектов. Постепенно он создает больший объект от малого и простого объекта.
* Prototype (Прототип) - помогает создать дублированный объект с лучшей производительностью, вместо нового создается возвращаемый клон существующего объекта.
Структурные:
* Adapter (Адаптер) - это конвертер между двумя несовместимыми объектами. Используя паттерн адаптера, мы можем объединить два несовместимых интерфейса.
* Composite (Компоновщик) - использует один класс для представления древовидной структуры.
* Proxy (Заместитель) - представляет функциональность другого класса.
* Flyweight (Легковес) - вместо создания большого количества похожих объектов, объекты используются повторно.
* Facade (Фасад) - беспечивает простой интерфейс для клиента, и клиент использует интерфейс для взаимодействия с системой.
* Bridge (Мост) - делает конкретные классы независимыми от классов реализации интерфейса.
* Decorator (Декоратор) - добавляет новые функциональные возможности существующего объекта без привязки его структуры.
Поведенческие:
* Template Method (Шаблонный метод) - определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
* Mediator (Посредник) - предоставляет класс посредника, который обрабатывает все коммуникации между различными классами.
* Chain of Responsibility (Цепочка обязанностей) - позволяет избежать жесткой зависимости отправителя запроса от его получателя, при этом запрос может быть обработан несколькими объектами.
* Observer (Наблюдатель) - позволяет одним обьектам следить и реагировать на события, происходящие в других объектах.
* Strategy (Стратегия) - алгоритм стратегии может быть изменен во время выполнения программы.
* Command (Команда) - интерфейс команды объявляет метод для выполнения определенного действия.
* State (Состояние) - объект может изменять свое поведение в зависимости от его состояния.
* Visitor (Посетитель) - используется для упрощения операций над группировками связанных объектов.
* Interpreter (Интерпретатор) - определяет грамматику простого языка для проблемной области.
* Iterator (Итератор) - последовательно осуществляет доступ к элементам объекта коллекции, не зная его основного представления.
* Memento (Хранитель) - используется для хранения состояния объекта, позже это состояние можно восстановить.

##  Что такое daemon тред?
Daemon thread (далее — демон-тред) — это тред, который выполняет задачи в фоне по отношению к другому потоку. То есть, его работа заключается в том, чтоб выполнять задачи вспомогательные, которые нужно делать только в привязке другому (основному) потоку. 

Есть много потоков демонов, работающих автоматически, например Garbage Collector, finalizer и т. д.
Почему Java закрывает демон-поток?
Единственная цель потока демона состоит в том, что он предоставляет сервисы потоку пользователя для фоновой задачи поддержки. Поэтому если основной поток завершился, то runtime закрывает автоматически и все его демон-потоки.

Мы можем создать поток демона только до его запуска.

## Что такое volatile переменная?
Ключевое слово volatile используется в многопоточном программировании для обеспечения безопасности потока, поскольку модификация одной изменяемой переменной видна всем другим потокам, поэтому одна переменная может использоваться одним потоком за раз.

При помощи ключевого слова volatile можно гарантировать, что переменная будет потокобезопасна и будет храниться в общей памяти, и потоки не будут ее брать себе в свой кеш.

## Что такое синхронизация (synchronization)?
Синхронизация (Synchronization) в Java — это возможность контролировать доступ нескольких потоков к любому общему ресурсу.

Когда несколько потоков пытаются выполнить одну и ту же задачу, существует вероятность ошибочного результата, поэтому для устранения этой проблемы Java использует синхронизацию, благодаря которой будет только один тред сможет работать в один момент.

Синхронизация может быть достигнута тремя способами:
* Синхронизируя метод
* Синхронизируя определенный блок
* Статической синхронизацией
Синхронизация метода
Синхронизированный метод используется для блокировки объекта для любого общего ресурса. Когда поток вызывает синхронизированный метод, он автоматически получает блокировку для этого объекта и снимает ее, когда поток завершает свою задачу.

Чтоб заработало, нужно добавить ключевое слово synchronized. 
Блок синхронизации
Синхронизированный блок может быть использован для выполнения синхронизации на любом конкретном ресурсе метода. 

Допустим, что в большом методе(да да, такие писать нельзя, но иногда бывает) нужно синхронизировать только небольшую часть, по каким-то причинам.

Если вы поместите все коды метода в синхронизированный блок, он будет работать так же, как синхронизированный метод.

Статическая синхронизация
Если сделать статический метод синхронизированным, то блокировка будет на классе, а не на объекте.

## Что такое shutdownhook?
Shutdownhook — это поток, который неявно вызывается до завершения работы JVM(виртуальная машина Java). Таким образом, мы можем использовать его для очистки ресурса или сохранения состояния, когда виртуальная машина Java выключается нормально или внезапно. 

##  Каковы состояния в жизненном цикле потока
1. New: В этом состоянии объект класса Thread создается с использованием оператора new, но поток не существует. Поток не запускается, пока мы не вызовем метод start().
2. Runnable: В этом состоянии поток готов к запуску после вызова метода start(). Однако он еще не выбран планировщиком потока.
3. Running: В этом состоянии планировщик потока выбирает поток из состояния готовности, и тот работает.
4. Waiting/Blocked: в этом состоянии поток не работает, но все еще жив или ожидает завершения другого потока.
5. Dead/Terminated: при выходе из метода run() поток находится в завершенном или мертвом состоянии.

## Object

1.Почему все наследуется от него? 
Нужно подумать про наследование
Чтобы определенный пул методов стандартных был у всех объектов, объект наследника может быть использован где нужно объект родителя

2.Для чего можно создать экземпляр обжекта? 

Например для монитора многопоточность


3. Методы класса 
hashCode(), equals(), ToString

Wait(), notify(), notifyall() - вызываются только внутри synchronize блока, используются для синхронизации, wait останавливает поток, notify пробуждает один поток notifyall пробуждает все потоки на мониторе.

getClass

Clone(), finalize()

## Concurrency

это библиотека классов в Java, в которой собрали специальные классы, оптимизированные для работы из нескольких нитей. Эти классы собраны в пакете java.util.concurrent.
Concurrent Collections — набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета. Вместо базового враппера Collections.synchronizedList с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа для параллельного чтения данных по wait-free алгоритмам.

Queues — неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков. Блокирующие очереди используются, когда нужно «притормозить» потоки «Producer» или «Consumer», если не выполнены какие-либо условия, например, очередь пуста или перепонена, или же нет свободного «Consumer»'a.

Synchronizers — вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.

Executors — содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов. 

Locks — представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.

Atomics — классы с поддержкой атомарных операций над примитивами и ссылками.

## Сериализация

Сериализация — это процесс, который переводит объект в последовательность байтов, по которой затем его можно полностью восстановить.При сериализации объекта сериализуются все объекты, на которые он ссылается в своих переменных экземпляра. 
Десериализация — это процесс восстановления объекта из этих байт.
Дополнительным бонусом ко всему является сохранение кроссплатформенности. 
Реализовать механизм сериализации довольно просто. Необходимо, чтобы ваш класс реализовывал интерфейс Serializable. Это интерфейс — идентификатор, который не имеет методов, но он указывает jvm, что объекты этого класса могут быть сериализованы. 

Что делать, если вы хотите управлять сериализацией сами? Существует два способа. Первый, использовать ключевое слово transient ( не дает полю сериализоваться). Второй, вместо реализации интереса Serializable использовать его расширение — интерфейс Externalizable.

## SOLID

S – Single Responsibility (Принцип единственной ответственности)

Каждый класс должен отвечать только за одну операцию.

Hазначение

Принцип служит для разделения типов поведения, благодаря которому ошибки, вызванные модификациями в одном поведении, не распространялись на прочие, не связанные с ним типы.

O — Open-Closed (Принцип открытости-закрытости)

Классы должны  быть  открыты для расширения, но закрыты для модификации.

Назначение

Принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс.

L — Liskov Substitution (Принцип подстановки Барбары Лисков)

Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы.

Назначение

Принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться одинаковым образом без нарушения работы программы.

I — Interface Segregation (Принцип разделения интерфейсов)

Не следует ставить клиент в зависимость от методов, которые он не использует.
Назначение

Принцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше – таким образом, каждый класс делает то, что от него действительно требуется, и ничего больше.

D — Dependency Inversion (Принцип инверсии зависимостей)

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
Назначение

Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов.

## Транзакция

 Группа последовательных операций с [базой данных](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B7%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85), которая представляет собой логическую единицу работы с данными. Транзакция может быть выполнена либо целиком и успешно, соблюдая целостность данных и независимо от параллельно идущих других транзакций, либо не выполнена вообще, и тогда она не должна произвести никакого эффекта.

## Уровни изоляции транзакций
Степень обеспечиваемой внутренними механизмами СУБД  защиты от всех или некоторых видов вышеперечисленных несогласованности данных, возникающих при параллельном выполнении транзакций.

Read uncommitted (чтение незафиксированных данных)
Низший (первый) уровень изоляции. Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определенное всем набором успешно выполненных транзакций. При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.

Read committed (чтение фиксированных данных)
На этом уровне обеспечивается защита от чернового, «грязного» чтения, тем не менее, в процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы. В итоге первая транзакция будет работать с другим набором данных.

Repeatable read (повторяющееся чтение)
Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны. При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена.

Serializable (упорядочиваемость)
Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга, каждая выполняется так, как будто параллельных транзакций не существует. Только на этом уровне параллельные транзакции не подвержены эффекту «фантомного чтения».

## ACID

Atomicity — Атомарность
Consistency — Согласованность
Isolation — Изолированность
Durability — Надёжность

Atomicity — Атомарность
Атомарность гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния.

Consistency — Согласованность
Транзакция, достигающая своего нормального завершения (EOT — end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных.


Isolation — Изолированность
Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат.


Durability — Надёжность/ Постоянство
Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя. Обесточилась система, произошел сбой в оборудовании? На выполненную транзакцию это не повлияет.

## MAVEN
 Инструмент для управления и сборки проектов

pom.xml - главный файл для управления Мавеном. Все описание проекта содержится здесь.

Благодаря Мавену не нужно тратить время на поиски нужной библиотеки в интернете, качать ее, а потом подключать к проекту: достаточно добавить необходимую в список зависимостей Мавена.

Сборка с помощью maven 
Существует 9 фаз:
1. clean — удаляются все скомпилированные файлы из каталога target (место, в котором сохраняются готовые артефакты);
2. validate — идет проверка, вся ли информация доступна для сборки проекта;
3. compile — компилируются файлы с исходным кодом;
4. test — запускаются тесты;
5. package — упаковываются скомпилированные файлы (в jar, war и т.д. архив);
6. verify — выполняются проверки для подтверждения готовности упакованного файла;
7. install — пакет помещается в локальный репозиторий. Теперь он может использоваться другими проектами как внешняя библиотека;
8. site — создается документация проекта;
9. deploy — собранный архив копируется в удаленный репозиторий.
Все фазы выполняются последовательно: нельзя запустить, скажем, четвертую фазы, пока не завершены фазы 1-3. 

